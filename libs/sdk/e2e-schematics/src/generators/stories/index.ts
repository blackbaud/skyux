import { angularStoriesGenerator } from '@nrwl/angular/generators';
import {
  ProjectConfiguration,
  Tree,
  formatFiles,
  getProjects,
  visitNotIgnoredFiles,
} from '@nrwl/devkit';

import {
  applyTransformers,
  getInsertStringPropertyTransformer,
  getRenameVariablesTransformer,
  getStringLiteral,
  getStringLiteralsSetterTransformer,
  readSourceFile,
  writeSourceFile,
} from '../../utils/ast-utils';

import { StoriesGeneratorSchema } from './schema';

interface NormalizedSchema extends StoriesGeneratorSchema {
  projectName: string;
  projectRoot: string;
  projectDirectory: string;
  e2eProjectDirectory: string | undefined;
  projectConfig: ProjectConfiguration;
}

function normalizeOptions(
  tree: Tree,
  options: StoriesGeneratorSchema
): NormalizedSchema {
  const projects = getProjects(tree);
  if (!projects.has(options.project)) {
    throw new Error(`Unable to find project ${options.project}`);
  }
  let projectConfig = projects.get(options.project);
  if (!('storybook' in projectConfig.targets)) {
    options.project = `${options.project}-storybook`;
    if (!projects.has(options.project)) {
      throw new Error(`Unable to find project ${options.project}`);
    }
    projectConfig = projects.get(options.project);
    if (!('storybook' in projectConfig.targets)) {
      throw new Error(`Storybook is not configured for ${options.project}`);
    }
  }
  const projectDirectory = projectConfig.sourceRoot;
  const projectName = options.project;
  const projectRoot = projectConfig.root;
  const e2eProjectConfig = projects.get(
    options.cypressProject || `${projectName}-e2e`
  );
  const e2eProjectDirectory = e2eProjectConfig.sourceRoot;

  return {
    ...options,
    projectName,
    projectRoot,
    projectDirectory,
    e2eProjectDirectory,
    projectConfig,
  };
}

function titleCase(string: string) {
  return string
    .replace(/[-_]/g, ' ')
    .replace(/\b[a-z]/g, (char) => char.toUpperCase());
}

export default async function (tree: Tree, options: StoriesGeneratorSchema) {
  const normalizedOptions = normalizeOptions(tree, options);

  // nx g @nrwl/angular:stories
  angularStoriesGenerator(tree, {
    name: normalizedOptions.projectName,
    cypressProject: normalizedOptions.cypressProject,
    generateCypressSpecs: normalizedOptions.generateCypressSpecs,
  });

  // Update the .stories.ts files that were generated by nx g @nrwl/angular:stories
  const changes = tree.listChanges();
  const updatedIds = new Map<string, string>();
  visitNotIgnoredFiles(tree, normalizedOptions.projectDirectory, (filepath) => {
    if (
      filepath.endsWith('.stories.ts') &&
      changes.findIndex(
        (change) => change.path === filepath && change.type === 'CREATE'
      ) > -1
    ) {
      const source = readSourceFile(tree, filepath);
      const componentClass = getStringLiteral(source, 'title');
      const newTitle = componentClass
        .replace(/Component$/, '')
        .replace(/(?<=[a-z])([A-Z])/g, ' $1');

      // Look for a directory to group this story in
      const paths = filepath
        .substring(normalizedOptions.projectConfig.sourceRoot.length + 1)
        .split('/');
      const filename = paths.pop();
      let componentGroup = '';
      for (let i = paths.length - 1; i >= 0; i--) {
        // Skip directory with the same name as the component or a set of generic names.
        if (
          !filename.startsWith(paths[i]) &&
          !['app', 'visual'].includes(paths[i])
        ) {
          componentGroup = `${titleCase(paths[i])}/`;
          break;
        }
      }

      // Rename "Primary" to a more descriptive name
      const renameTransformer = getRenameVariablesTransformer({
        Primary: newTitle.replace(/ /g, ''),
      });
      // Update the title to include the directory and a more descriptive name
      const setStringTransformer = getStringLiteralsSetterTransformer({
        title: `Components/${componentGroup}${newTitle}`,
      });
      // Create an "id" property to match the default id that the Cypress tests use
      const storyId = `${componentClass.toLowerCase()}-${newTitle
        .replace(/ /g, '')
        .toLowerCase()}`;
      const insertStringTransformer = getInsertStringPropertyTransformer(
        'title',
        'id',
        storyId
      );
      // Apply the transformers to the source file
      const [updated] = applyTransformers(
        [source],
        [renameTransformer, setStringTransformer, insertStringTransformer]
      );
      writeSourceFile(tree, filepath, updated);
      updatedIds.set(
        `${componentClass.toLowerCase()}--primary`,
        `${storyId}--${newTitle.replace(/ /g, '').toLowerCase()}`
      );
    }
  });
  if (normalizedOptions.e2eProjectDirectory) {
    visitNotIgnoredFiles(
      tree,
      normalizedOptions.e2eProjectDirectory,
      (filepath) => {
        const changeIndex = changes.findIndex(
          (change) => change.path === filepath && change.type === 'CREATE'
        );
        if (filepath.endsWith('.spec.ts') && changeIndex > -1) {
          let spec = tree.read(filepath, 'utf8');
          spec = spec
            .replace(
              /cy\.visit\('\/iframe.html\?id=([^']+)'\)/,
              (m, id) => `cy.visit('/iframe.html?id=${updatedIds.get(id)}')`
            )
            .replace(
              `.should('exist')`,
              `.should('exist')
            .should('be.visible')
            .screenshot()
            .percySnapshot()`
            );
          tree.write(filepath, spec);
        }
      }
    );
  }
  await formatFiles(tree);
}
